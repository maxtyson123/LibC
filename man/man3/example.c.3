.TH "/home/runner/work/LibC/LibC/src/_platforms/example.c" 3 "Version 0.3" "LibC" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/runner/work/LibC/LibC/src/_platforms/example.c \- Example implementations of functions that are specific to an platform that this libc is compiled for\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <errno\&.h>\fP
.br
\fC#include <sys/stat\&.h>\fP
.br
\fC#include <_platforms/example\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "int \fB_platform_exit\fP (int code)"
.br
.RI "Exit the current process without closing files\&. "
.ti -1c
.RI "int \fB_platform_execve\fP (char *name, char **argv, char **env)"
.br
.RI "Transfer execution to another process\&. "
.ti -1c
.RI "int \fB_platform_fork\fP (void)"
.br
.RI "Create a copy of this process\&. "
.ti -1c
.RI "int \fB_platform_getpid\fP (void)"
.br
.RI "Get the ID of the executing process\&. "
.ti -1c
.RI "int \fB_platform_kill\fP (int pid, int sig)"
.br
.RI "Send a signal to a process\&. "
.ti -1c
.RI "int \fB_platform_times\fP (struct tms *buf)"
.br
.RI "Get process times\&. "
.ti -1c
.RI "int \fB_platform_wait\fP (int *status)"
.br
.RI "Wait for a child process to change state\&. "
.ti -1c
.RI "int \fB_platform_close\fP (int file)"
.br
.RI "Close a file\&. "
.ti -1c
.RI "int \fB_platform_fstat\fP (int file, struct \fBstat\fP *st)"
.br
.RI "Get the status of a file\&. "
.ti -1c
.RI "int \fB_platform_isatty\fP (int file)"
.br
.RI "Determine if a file descriptor is a terminal\&. "
.ti -1c
.RI "int \fB_platform_link\fP (char *old, char *new)"
.br
.RI "Create a new link (hard link) to an existing file\&. "
.ti -1c
.RI "int \fB_platform_lseek\fP (int file, int ptr, int dir)"
.br
.RI "Reposition the read/write file offset\&. "
.ti -1c
.RI "int \fB_platform_open\fP (const char *name, int flags, int mode)"
.br
.RI "Open a file\&. "
.ti -1c
.RI "int \fB_platform_read\fP (int file, char *ptr, int len)"
.br
.RI "Read from a file\&. "
.ti -1c
.RI "int \fB_platform_stat\fP (char *file, struct \fBstat\fP *st)"
.br
.RI "Get the status of a file by name\&. "
.ti -1c
.RI "int \fB_platform_unlink\fP (char *name)"
.br
.RI "Remove a file\&. "
.ti -1c
.RI "int \fB_platform_write\fP (int file, char *ptr, int len)"
.br
.RI "Write to a file\&. "
.ti -1c
.RI "void * \fB_platform_sbrk\fP (int incr)"
.br
.RI "Increment the program's data space\&. "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "char * \fB__env\fP [1] = { 0 }"
.br
.RI "Platform specific storage for the environment variables\&. "
.ti -1c
.RI "char ** \fBenviron\fP = \fB__env\fP"
.br
.RI "Environment pointer\&. "
.in -1c
.SH "Detailed Description"
.PP 
Example implementations of functions that are specific to an platform that this libc is compiled for\&. 


.PP
\fBDate\fP
.RS 4
14 December 2025 
.RE
.PP
\fBAuthor\fP
.RS 4
Max Tyson
.RE
.PP
@credit https://sourceware.org/newlib/libc.html 
.PP
Definition in file \fBexample\&.c\fP\&.
.SH "Function Documentation"
.PP 
.SS "int _platform_close (int file)"

.PP
Close a file\&. 
.PP
\fBNote\fP
.RS 4
Stub implementation: Return -1 but no errno
.RE
.PP
\fBParameters\fP
.RS 4
\fIfile\fP The file descriptor for the file requesting to be closed 
.RE
.PP
\fBReturns\fP
.RS 4
.RE
.PP

.PP
Definition at line \fB110\fP of file \fBexample\&.c\fP\&..PP
.nf
110                               {
111     return \-1;
112 }
.fi

.SS "int _platform_execve (char * name, char ** argv, char ** env)"

.PP
Transfer execution to another process\&. 
.PP
\fBNote\fP
.RS 4
Stub implementation: Will error - no memory
.RE
.PP
\fBParameters\fP
.RS 4
\fIname\fP The executable to transfer to 
.br
\fIargv\fP The list of args to pass to the new process 
.br
\fIenv\fP The environment variables to pass to the new process 
.RE
.PP
\fBReturns\fP
.RS 4
Won't return on success otherwise -1 on error 
.RE
.PP

.PP
Definition at line \fB39\fP of file \fBexample\&.c\fP\&..PP
.nf
39                                                           {
40     errno = ENOMEM;
41     return \-1;
42 }
.fi

.PP
References \fBENOMEM\fP\&.
.SS "int _platform_exit (int code)"

.PP
Exit the current process without closing files\&. 
.PP
\fBNote\fP
.RS 4
Stub implementation: will spin forever
.RE
.PP
\fBParameters\fP
.RS 4
\fIcode\fP The outcome of the process (0 is success, fail otherwise) 
.RE
.PP
\fBReturns\fP
.RS 4
Nothing, error code if failed to close 
.RE
.PP

.PP
Definition at line \fB22\fP of file \fBexample\&.c\fP\&..PP
.nf
22                              {
23 
24     // Spin forever
25     while(1)
26         asm("nop");
27 
28 }
.fi

.SS "int _platform_fork (void)"

.PP
Create a copy of this process\&. 
.PP
\fBNote\fP
.RS 4
Stub implementation: Will error - resource unavailable
.RE
.PP
\fBReturns\fP
.RS 4
0 for parent (current), new PID for child (the copy) or -1 on an error 
.RE
.PP

.PP
Definition at line \fB50\fP of file \fBexample\&.c\fP\&..PP
.nf
50                          {
51     errno = EAGAIN;
52     return \-1;
53 }
.fi

.PP
References \fBEAGAIN\fP\&.
.SS "int _platform_fstat (int file, struct \fBstat\fP * st)"

.PP
Get the status of a file\&. 
.PP
\fBNote\fP
.RS 4
Stub implementation: Always return character device
.RE
.PP
\fBParameters\fP
.RS 4
\fIfile\fP The file descriptor for the file requesting the stats of 
.br
\fIst\fP The buffer to put the status information into 
.RE
.PP
\fBReturns\fP
.RS 4
0 for success or -1 on error 
.RE
.PP

.PP
Definition at line \fB122\fP of file \fBexample\&.c\fP\&..PP
.nf
122                                                {
123     st\->st_mode = S_IFCHR;
124     return 0;
125 }
.fi

.PP
References \fBS_IFCHR\fP, and \fBstat::st_mode\fP\&.
.SS "int _platform_getpid (void)"

.PP
Get the ID of the executing process\&. 
.PP
\fBNote\fP
.RS 4
Stub implementation: Always return 1
.RE
.PP
\fBReturns\fP
.RS 4
The ID 
.RE
.PP

.PP
Definition at line \fB61\fP of file \fBexample\&.c\fP\&..PP
.nf
61                            {
62 
63     return 1;
64 }
.fi

.PP
Referenced by \fBraise()\fP\&.
.SS "int _platform_isatty (int file)"

.PP
Determine if a file descriptor is a terminal\&. 
.PP
\fBNote\fP
.RS 4
Stub implementation: Always return true
.RE
.PP
\fBParameters\fP
.RS 4
\fIfile\fP The file descriptor to check 
.RE
.PP
\fBReturns\fP
.RS 4
1 if it is a terminal, 0 otherwise 
.RE
.PP

.PP
Definition at line \fB134\fP of file \fBexample\&.c\fP\&..PP
.nf
134                                {
135     return 1;
136 }
.fi

.SS "int _platform_kill (int pid, int sig)"

.PP
Send a signal to a process\&. 
.PP
\fBNote\fP
.RS 4
Stub implementation: Always return error invalid argument
.RE
.PP
\fBParameters\fP
.RS 4
\fIpid\fP The process ID to send the signal to 
.br
\fIsig\fP The signal to send 
.RE
.PP
\fBReturns\fP
.RS 4
0 for success or -1 on error 
.RE
.PP

.PP
Definition at line \fB74\fP of file \fBexample\&.c\fP\&..PP
.nf
74                                      {
75     errno = EINVAL;
76     return \-1;
77 }
.fi

.PP
References \fBEINVAL\fP\&.
.PP
Referenced by \fBkill()\fP\&.
.SS "int _platform_link (char * old, char * new)"

.PP
Create a new link (hard link) to an existing file\&. 
.PP
\fBNote\fP
.RS 4
Stub implementation: Always return error too many links
.RE
.PP
\fBParameters\fP
.RS 4
\fIold\fP The existing file 
.br
\fInew\fP The new link to create 
.RE
.PP
\fBReturns\fP
.RS 4
0 for success or -1 on error 
.RE
.PP

.PP
Definition at line \fB146\fP of file \fBexample\&.c\fP\&..PP
.nf
146                                          {
147     errno = EMLINK;
148     return \-1;
149 }
.fi

.PP
References \fBEMLINK\fP\&.
.SS "int _platform_lseek (int file, int ptr, int dir)"

.PP
Reposition the read/write file offset\&. 
.PP
\fBNote\fP
.RS 4
Stub implementation: Seeks to start of file always
.RE
.PP
\fBParameters\fP
.RS 4
\fIfile\fP The file descriptor to reposition 
.br
\fIptr\fP Where to reposition to 
.br
\fIdir\fP How to reposition (SEEK_SET, SEEK_CUR, SEEK_END) 
.RE
.PP
\fBReturns\fP
.RS 4
The new offset or -1 on error 
.RE
.PP

.PP
Definition at line \fB160\fP of file \fBexample\&.c\fP\&..PP
.nf
160                                                 {
161     return 0;
162 }
.fi

.SS "int _platform_open (const char * name, int flags, int mode)"

.PP
Open a file\&. 
.PP
\fBNote\fP
.RS 4
Stub implementation: Always return error no such file or directory
.RE
.PP
\fBParameters\fP
.RS 4
\fIname\fP The name of the file to open 
.br
\fIflags\fP The flags for opening the file 
.br
\fImode\fP The mode to open the file with 
.RE
.PP
\fBReturns\fP
.RS 4
The file descriptor or -1 on error 
.RE
.PP

.PP
Definition at line \fB173\fP of file \fBexample\&.c\fP\&..PP
.nf
173                                                           {
174 
175     errno = ENOENT;
176     return \-1;
177 }
.fi

.PP
References \fBENOENT\fP\&.
.SS "int _platform_read (int file, char * ptr, int len)"

.PP
Read from a file\&. 
.PP
\fBNote\fP
.RS 4
Stub implementation: Always return 0 bytes read (EOF)
.RE
.PP
\fBParameters\fP
.RS 4
\fIfile\fP The file descriptor to read from 
.br
\fIptr\fP The buffer to read into 
.br
\fIlen\fP The number of bytes to read 
.RE
.PP
\fBReturns\fP
.RS 4
The number of bytes read or -1 on error 
.RE
.PP

.PP
Definition at line \fB188\fP of file \fBexample\&.c\fP\&..PP
.nf
188                                                  {
189     return 0;
190 }
.fi

.SS "void * _platform_sbrk (int incr)"

.PP
Increment the program's data space\&. 
.PP
\fBNote\fP
.RS 4
Stub implementation: Returns -1 (no memory)
.RE
.PP
\fBParameters\fP
.RS 4
\fIincr\fP The amount to increase the data space by 
.RE
.PP
\fBReturns\fP
.RS 4
The previous end of data space or -1 on error 
.RE
.PP

.PP
Definition at line \fB241\fP of file \fBexample\&.c\fP\&..PP
.nf
241                                {
242 
243     errno = ENOMEM;
244     return (void*)\-1;
245 
246 }
.fi

.PP
References \fBENOMEM\fP\&.
.SS "int _platform_stat (char * file, struct \fBstat\fP * st)"

.PP
Get the status of a file by name\&. 
.PP
\fBNote\fP
.RS 4
Stub implementation: Always return character device
.RE
.PP
\fBParameters\fP
.RS 4
\fIfile\fP The name of the file requesting the stats of 
.br
\fIst\fP The buffer to put the status information into 
.RE
.PP
\fBReturns\fP
.RS 4
0 for success or -1 on error 
.RE
.PP

.PP
Definition at line \fB200\fP of file \fBexample\&.c\fP\&..PP
.nf
200                                                 {
201 
202     st\->st_mode = S_IFCHR;
203     return 0;
204 
205 }
.fi

.PP
References \fBS_IFCHR\fP, and \fBstat::st_mode\fP\&.
.SS "int _platform_times (struct tms * buf)"

.PP
Get process times\&. 
.PP
\fBNote\fP
.RS 4
Stub implementation: Always return error invalid argument
.RE
.PP
\fBParameters\fP
.RS 4
\fIbuf\fP The buffer to put the times into 
.RE
.PP
\fBReturns\fP
.RS 4
The clock ticks or -1 on error 
.RE
.PP

.PP
Definition at line \fB86\fP of file \fBexample\&.c\fP\&..PP
.nf
86                                      {
87     errno = EINVAL;
88     return \-1;
89 }
.fi

.PP
References \fBEINVAL\fP\&.
.SS "int _platform_unlink (char * name)"

.PP
Remove a file\&. 
.PP
\fBNote\fP
.RS 4
Stub implementation: Always return error no such file or directory
.RE
.PP
\fBParameters\fP
.RS 4
\fIname\fP The name of the file to remove 
.RE
.PP
\fBReturns\fP
.RS 4
0 for success or -1 on error 
.RE
.PP

.PP
Definition at line \fB214\fP of file \fBexample\&.c\fP\&..PP
.nf
214                                  {
215 
216     errno = ENOENT;
217     return \-1;
218 
219 }
.fi

.PP
References \fBENOENT\fP\&.
.SS "int _platform_wait (int * status)"

.PP
Wait for a child process to change state\&. 
.PP
\fBNote\fP
.RS 4
Stub implementation: Always return error no child processes
.RE
.PP
\fBParameters\fP
.RS 4
\fIstatus\fP The buffer to put the status into 
.RE
.PP
\fBReturns\fP
.RS 4
The PID of the child that changed state or -1 on error 
.RE
.PP

.PP
Definition at line \fB98\fP of file \fBexample\&.c\fP\&..PP
.nf
98                                 {
99     errno = ECHILD;
100     return \-1;
101 }
.fi

.PP
References \fBECHILD\fP\&.
.SS "int _platform_write (int file, char * ptr, int len)"

.PP
Write to a file\&. 
.PP
\fBNote\fP
.RS 4
Stub implementation: Always return len (all bytes written)
.RE
.PP
\fBParameters\fP
.RS 4
\fIfile\fP The file descriptor to write to 
.br
\fIptr\fP The buffer to write from 
.br
\fIlen\fP The number of bytes to write 
.RE
.PP
\fBReturns\fP
.RS 4
The number of bytes written or -1 on error 
.RE
.PP

.PP
Definition at line \fB230\fP of file \fBexample\&.c\fP\&..PP
.nf
230                                                   {
231     return len;
232 }
.fi

.SH "Variable Documentation"
.PP 
.SS "char* __env[1] = { 0 }"

.PP
Platform specific storage for the environment variables\&. 
.PP
Definition at line \fB248\fP of file \fBexample\&.c\fP\&..PP
.nf
248 { 0 };
.fi

.SS "char** environ = \fB__env\fP"

.PP
Environment pointer\&. 
.PP
\fBTodo\fP
.RS 4
this isnt platform specific 
.RE
.PP

.PP
Definition at line \fB249\fP of file \fBexample\&.c\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for LibC from the source code\&.
